INTERVIEW FOLLOW-UP QUESTIONS – GRAPH CLONING / GRAPH PROBLEMS
=============================================================

Q1. Can you solve it using BFS?
--------------------------------
Yes, the problem can be solved using Breadth First Search (BFS).

In a BFS-based solution:
- We start from the given node.
- Use a queue to traverse the graph level by level.
- Maintain a hash map (original node → cloned node) to avoid cloning the same node multiple times.
- For each node popped from the queue:
  - Visit all its neighbors.
  - If a neighbor is not yet cloned, create its clone and push the neighbor into the queue.
  - Add the cloned neighbor to the current node’s cloned neighbor list.

Why BFS works:
- BFS ensures we visit every reachable node exactly once.
- The visited map prevents infinite loops in cyclic graphs.
- BFS avoids deep recursion, so it is safer for very deep graphs.

Time Complexity:
- O(V + E), where V is the number of vertices and E is the number of edges.

Space Complexity:
- O(V) for the queue and the hash map.

--------------------------------

Q2. What happens if the graph is disconnected?
-----------------------------------------------
If the graph is disconnected, starting BFS or DFS from a single node will only clone the connected component that contains that node.

Important clarification:
- In many interview problems (like LeetCode Clone Graph), the input guarantees a connected graph.
- If the graph is not guaranteed to be connected, we must:
  - Iterate over all nodes in the graph.
  - Start a BFS/DFS from each unvisited node.
  - Clone each connected component separately.

Key Interview Insight:
- A graph cloning solution should clearly mention whether the graph is assumed to be connected.
- If not specified, always handle disconnected graphs explicitly.

--------------------------------

Q3. How do you handle self-loops?
---------------------------------
A self-loop occurs when a node has an edge to itself.

Handling self-loops during cloning:
- When cloning a node, we first create its copy and store it in the map.
- While iterating through neighbors:
  - If the neighbor is the same node (self-loop), the map already contains its cloned version.
  - We simply add the cloned node to its own neighbor list.

Why this works:
- The visited/cloned map prevents infinite recursion.
- Self-loops naturally get replicated without any special condition.

Interview Tip:
- Mention that self-loops are handled automatically if the visited map is used correctly.

--------------------------------

Q4. Can you explain deep copy vs shallow copy?
-----------------------------------------------
Yes, this is a very important concept.

Shallow Copy:
- Copies only the reference (pointer) to the original object.
- Both original and copied objects point to the same memory.
- Changes in one object affect the other.
- Not suitable for graph cloning.

Example:
- Copying a pointer without creating new nodes.

Deep Copy:
- Creates an entirely new object with new memory.
- All nested objects (neighbors in a graph) are also copied.
- Changes in the cloned object do NOT affect the original.

In graph cloning:
- We must perform a DEEP COPY.
- Every node is newly created.
- All edges are recreated using cloned nodes.
- No memory is shared with the original graph.

Interview One-Liner:
“Graph cloning requires a deep copy because each node and its connections must be recreated independently.”

--------------------------------

KEY INTERVIEW TAKEAWAY
----------------------
- BFS and DFS are both valid for graph cloning.
- Always use a visited/hash map.
- Handle cycles, self-loops, and disconnected components.
- Emphasize deep copy over shallow copy.
- Explain your approach before writing code.

This demonstrates strong problem-solving and system-level thinking.
